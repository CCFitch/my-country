{"meta":{"title":"陈灿丰的博客","subtitle":"","description":"","author":"陈灿丰","url":"git@github.com:CCFitch/mycountry.git","root":"mycountry/"},"pages":[{"title":"react-life-cycle","date":"2019-12-17T13:23:53.000Z","updated":"2019-12-17T13:23:53.155Z","comments":true,"path":"react-life-cycle/index.html","permalink":"git@github.com:CCFitch/mycountry.git/react-life-cycle/index.html","excerpt":"","text":""},{"title":"react-life-cycle","date":"2019-12-17T13:29:43.000Z","updated":"2019-12-17T13:29:43.968Z","comments":true,"path":"react-life-cycle/index-1.html","permalink":"git@github.com:CCFitch/mycountry.git/react-life-cycle/index-1.html","excerpt":"","text":""}],"posts":[{"title":"react-life-cycle","slug":"react-life-cycle","date":"2019-12-17T13:14:33.890Z","updated":"2019-12-17T13:12:47.781Z","comments":true,"path":"2019/12/17/react-life-cycle/","link":"","permalink":"git@github.com:CCFitch/mycountry.git/2019/12/17/react-life-cycle/","excerpt":"","text":"react生命周期一、挂载卸载过程 constructor() constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。 componentWillMount() componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。 componentDidMount() 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染 componentWillUnmount () 在此处完成组件的卸载和数据的销毁。 clear你在组建中所有的setTimeout,setInterval移除所有组建中的监听 removeEventListener有时候我们会碰到这个warning: 1Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the undefined component. 解决办法： 1234567891011componentDidMount() &#123; this.isMount === true axios.post().then((res) =&gt; &#123; this.isMount &amp;&amp; this.setState(&#123; // 增加条件ismount为true时 aaa:res &#125;)&#125;)&#125;componentWillUnmount() &#123; this.isMount === false&#125; 二、更新过程 componentWillReceiveProps (nextProps) 在接受父组件改变后的props需要重新渲染组件时用到的比较多 接受一个参数nextProps 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件 12345678componentWillReceiveProps (nextProps) &#123; nextProps.openNotice !== this.props.openNotice&amp;&amp;this.setState(&#123; openNotice:nextProps.openNotice &#125;，() =&gt; &#123; console.log(this.state.openNotice:nextProps) //将state更新为nextProps,在setState的第二个参数（回调）可以打 印出新的state &#125;)&#125; shouldComponentUpdate(nextProps,nextState) 主要用于性能优化(部分更新)唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断 componentWillUpdate (nextProps,nextState) shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。 componentDidUpdate(prevProps,prevState) 组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。 render() render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。 三、React新增的生命周期(个人补充) getDerivedStateFromProps(nextProps, prevState) 代替componentWillReceiveProps()。老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。 这两者最大的不同就是:在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。 在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。 getSnapshotBeforeUpdate(prevProps, prevState) 代替componentWillUpdate。常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。这两者的区别在于： 在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。","categories":[],"tags":[]},{"title":"第一个博客测试","slug":"my-first-blog","date":"2019-11-16T03:57:40.359Z","updated":"2019-11-16T08:08:30.332Z","comments":true,"path":"2019/11/16/my-first-blog/","link":"","permalink":"git@github.com:CCFitch/mycountry.git/2019/11/16/my-first-blog/","excerpt":"","text":"欢迎12 欢迎 第一个博客标题一1$ hexo new \"My New Post\" 查看更多: Writing 标题二1$ hexo server 查看更多: Server 超链接：123 标题san1$ hexo generate 查看更多: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-11-02T04:02:58.151Z","updated":"2019-11-02T04:02:58.152Z","comments":true,"path":"2019/11/02/hello-world/","link":"","permalink":"git@github.com:CCFitch/mycountry.git/2019/11/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}